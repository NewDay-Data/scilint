# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/indicators.ipynb.

# %% auto 0
__all__ = ['indicator_funcs', 'CodeParseError', 'calls_per_func', 'calls_per_func_mean', 'calls_per_func_median',
           'traverse_asserts', 'tests_per_function', 'tests_per_func_mean', 'tests_func_coverage_pct', 'calc_ifp',
           'in_func_pct', 'markdown_code_pct', 'total_code_len', 'loc_per_md_section']

# %% ../nbs/indicators.ipynb 2
import ast
import datetime
import logging
import re
import warnings
from collections import Counter
from importlib import reload
from pathlib import Path

import nbformat
import numpy as np
import pandas as pd
from execnb.nbio import read_nb

from .utils import get_cell_code, remove_ipython_special_directives

# %% ../nbs/indicators.ipynb 7
class CodeParseError(Exception):
    pass

# %% ../nbs/indicators.ipynb 11
def _count_func_calls(code, func_defs, out_dir=None):
    func_calls = Counter({k: 0 for k in func_defs})

    def get_func_name(node):
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            return node.attr
        return None

    try:
        for stmt in ast.walk(ast.parse(code)):
            if isinstance(stmt, ast.Call):
                func_name = get_func_name(stmt.func)
                if func_name and func_name in func_defs:
                    func_calls[func_name] += 1
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path, "w") as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return func_calls

# %% ../nbs/indicators.ipynb 16
def _get_func_defs(code, ignore_private_prefix=True, out_dir=None):
    func_names = []
    try:
        for stmt in ast.walk(ast.parse(code)):
            if isinstance(stmt, ast.FunctionDef):
                inner_cond = (
                    False
                    if ignore_private_prefix and stmt.name.startswith("_")
                    else True
                )
                if inner_cond:
                    func_names.append(stmt.name)
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path, "w") as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return func_names

# %% ../nbs/indicators.ipynb 21
def calls_per_func(nb, out_dir=None):
    nb_cell_code = get_cell_code(nb)
    func_defs = _get_func_defs(nb_cell_code, out_dir)
    func_calls = _count_func_calls(nb_cell_code, func_defs, out_dir)
    return func_calls

# %% ../nbs/indicators.ipynb 23
def calls_per_func_mean(nb, out_dir=None):
    return pd.Series(calls_per_func(nb, out_dir)).mean()

# %% ../nbs/indicators.ipynb 25
def calls_per_func_median(nb, out_dir=None):
    with warnings.catch_warnings():
        warnings.filterwarnings(action="ignore", message="Mean of empty slice")
        return pd.Series(calls_per_func(nb)).median()

# %% ../nbs/indicators.ipynb 32
def _count_inline_asserts(code, func_defs, out_dir=None):
    inline_func_asserts = Counter({k: 0 for k in func_defs})

    try:
        for stmt in ast.walk(ast.parse(code)):
            if isinstance(stmt, ast.Assert):
                for assert_st in ast.walk(stmt):
                    if isinstance(assert_st, ast.Call):
                        if hasattr(assert_st.func, "id"):
                            func_name = assert_st.func.id
                        elif hasattr(assert_st.func, "attr"):
                            func_name = assert_st.func.attr
                        elif isinstance(assert_st.func, ast.Call) and hasattr(
                            assert_st.func.func, "id"
                        ):
                            # Handle case where function name is result of another function call
                            func_name = assert_st.func.func.id
                            # Skip counting the outer function call
                            continue
                        else:
                            continue

                        if func_name in inline_func_asserts:
                            inline_func_asserts[func_name] += 1
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path, "w") as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return inline_func_asserts

# %% ../nbs/indicators.ipynb 35
def _count_func_ret_asserts(code, out_dir=None):
    ret_vals = {}
    func_defs = _get_func_defs(code)
    func_ret_asserts = Counter({k: 0 for k in func_defs})
    assert_func_counts = {}
    try:
        for stmt in ast.walk(ast.parse(code)):
            if isinstance(stmt, ast.Assign) and isinstance(stmt.value, ast.Call):
                _update_ret_vals(stmt, ret_vals)

            if isinstance(stmt, ast.Assert):
                assert_func_counts[id(stmt)] = []
                traverse_asserts(
                    stmt, ret_vals, func_ret_asserts, assert_func_counts, stmt.test
                )
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path, "w") as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return func_ret_asserts

# %% ../nbs/indicators.ipynb 36
def _incr_assert_count(
    assert_id, ret_vals, func_ret_asserts, assert_func_counts, return_var
):
    if (
        return_var in ret_vals
        and ret_vals[return_var] not in assert_func_counts[assert_id]
    ):
        assert_func_counts[assert_id].append(ret_vals[return_var])
        if return_var in ret_vals:
            func_ret_asserts[ret_vals[return_var]] += 1

# %% ../nbs/indicators.ipynb 38
def _update_ret_vals(stmt, ret_vals):
    func_name = None

    if isinstance(stmt.value.func, ast.Name):
        func_name = stmt.value.func.id
    elif isinstance(stmt.value.func, ast.Attribute):
        func_name = stmt.value.func.attr

    if func_name:
        if isinstance(stmt.targets[0], ast.Name):
            ret_vals[stmt.targets[0].id] = func_name
        elif isinstance(stmt.targets[0], ast.Tuple):
            for elts in stmt.targets[0].elts:
                if isinstance(elts, ast.Name):
                    ret_vals[elts.id] = func_name

# %% ../nbs/indicators.ipynb 40
def traverse_asserts(
    stmt: ast.AST, ret_vals, func_ret_asserts, assert_func_counts, node: ast.AST
):
    # increment function assert count if return val can be matched to defined function
    if hasattr(node, "id"):
        _incr_assert_count(
            id(stmt),
            ret_vals,
            func_ret_asserts,
            assert_func_counts,
            node.id,
        )
    # Perform recursive traversals
    children_attrs = ("left", "func", "value", "comparators", "args", "values")
    for attr in children_attrs:
        child = getattr(node, attr, None)
        if isinstance(child, list):
            for item in child:
                traverse_asserts(
                    stmt, ret_vals, func_ret_asserts, assert_func_counts, item
                )
        elif child is not None:
            traverse_asserts(
                stmt, ret_vals, func_ret_asserts, assert_func_counts, child
            )

# %% ../nbs/indicators.ipynb 43
def tests_per_function(nb, out_dir=None):
    nb_cell_code = "\n".join(
        [
            remove_ipython_special_directives(c["source"])
            for c in nb.cells
            if c["cell_type"] == "code"
        ]
    )
    return _tests_per_function_code(nb_cell_code, out_dir)

# %% ../nbs/indicators.ipynb 45
def _tests_per_function_code(nb_cell_code, out_dir=None):
    func_ret_asserts = _count_func_ret_asserts(nb_cell_code, out_dir)
    inline_asserts = _count_inline_asserts(
        nb_cell_code, _get_func_defs(nb_cell_code, out_dir), out_dir
    )

    func_ret_asserts.update(inline_asserts)
    return pd.Series(func_ret_asserts)

# %% ../nbs/indicators.ipynb 49
def tests_per_func_mean(nb, out_dir=None):
    return tests_per_function(nb, out_dir).mean()

# %% ../nbs/indicators.ipynb 51
def tests_func_coverage_pct(nb, out_dir=None):
    return tests_per_function(nb, out_dir).clip(upper=1).mean() * 100

# %% ../nbs/indicators.ipynb 57
def calc_ifp(code, out_dir=None):
    stmts_in_func = 0
    stmts_outside_func = 0
    try:
        for stmt in ast.walk(ast.parse(remove_ipython_special_directives(code))):
            if isinstance(stmt, ast.FunctionDef) and not stmt.name.startswith("_"):
                for body_item in stmt.body:
                    stmts_in_func += 1
            elif isinstance(stmt, ast.Module):
                for body_item in stmt.body:
                    if not isinstance(body_item, ast.FunctionDef):
                        stmts_outside_func += 1
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path, "w") as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return (
        0
        if stmts_outside_func + stmts_in_func == 0
        else (stmts_in_func / (stmts_outside_func + stmts_in_func)) * 100
    )

# %% ../nbs/indicators.ipynb 60
def in_func_pct(nb, out_dir=None):
    nb_cell_code = "\n".join(
        [
            remove_ipython_special_directives(c["source"])
            for c in nb.cells
            if c["cell_type"] == "code"
        ]
    )
    if nb_cell_code == "":
        return np.nan
    return calc_ifp(nb_cell_code, out_dir)

# %% ../nbs/indicators.ipynb 64
def markdown_code_pct(nb, out_dir=None):
    md_cells = [c for c in nb.cells if c["cell_type"] == "markdown"]
    code_cells = [c for c in nb.cells if c["cell_type"] == "code"]
    num_code_cells = len(code_cells)
    if num_code_cells == 0:
        return np.nan
    num_md_cells = len(md_cells)
    return (
        100
        if num_code_cells == 0
        else (num_md_cells / (num_md_cells + num_code_cells)) * 100
    )

# %% ../nbs/indicators.ipynb 68
def total_code_len(nb, out_dir=None):
    return sum([len(c["source"]) for c in nb.cells if c["cell_type"] == "code"])

# %% ../nbs/indicators.ipynb 72
def loc_per_md_section(nb, out_dir=None):
    num_md_sections = len(
        [
            c["source"]
            for c in nb.cells
            if c["cell_type"] == "markdown" and c["source"].strip().startswith("#")
        ]
    )
    tcl = total_code_len(nb)
    if tcl == 0 or num_md_sections == 0:
        result = np.nan
    else:
        result = total_code_len(nb) / num_md_sections
    return result

# %% ../nbs/indicators.ipynb 75
indicator_funcs = {
    "calls_per_func_mean": calls_per_func_mean,
    "calls_per_func_median": calls_per_func_median,
    "tests_per_func_mean": tests_per_func_mean,
    "tests_func_coverage_pct": tests_func_coverage_pct,
    "in_func_pct": in_func_pct,
    "markdown_code_pct": markdown_code_pct,
    "loc_per_md_section": loc_per_md_section,
    "total_code_len": total_code_len,
}
