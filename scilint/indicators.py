# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/indicators.ipynb.

# %% auto 0
__all__ = ['indicator_funcs', 'CodeParseError', 'gen_parse_filename', 'calls_per_func', 'calls_per_func_mean',
           'calls_per_func_median', 'traverse_asserts', 'tests_per_function', 'tests_per_func_mean',
           'tests_func_coverage_pct', 'calc_ifp', 'in_func_pct', 'markdown_code_pct', 'total_code_len',
           'loc_per_md_section']

# %% ../nbs/indicators.ipynb 2
import ast
import warnings
from collections import Counter
from pathlib import Path
import logging
from importlib import reload
import re
import datetime

import nbformat
import numpy as np
import pandas as pd
from execnb.nbio import read_nb

from .utils import get_cell_code, remove_ipython_special_directives

# %% ../nbs/indicators.ipynb 7
class CodeParseError(Exception):
    pass

# %% ../nbs/indicators.ipynb 8
def gen_parse_filename(code: str, now: datetime = None):
    cleaned_code = re.sub("\W+", "-", code)[:10].strip("-")
    if now is None:
        now = datetime.datetime.now()
    return cleaned_code + "_" + now.strftime("%Y%m%d_%H_%M_%S")

# %% ../nbs/indicators.ipynb 11
def _count_func_calls(code, func_defs, out_dir=None):
    func_calls = Counter({k: 0 for k in func_defs})
    try:
        for stmt in ast.walk(ast.parse(code)):
            if isinstance(stmt, ast.Call) and not isinstance(stmt.func, ast.Call):
                if type(stmt.func) == ast.Subscript:
                    func_name = stmt.func.value.id
                else:
                    func_name = (
                        stmt.func.id if "id" in stmt.func.__dict__ else stmt.func.attr
                    )
                if func_name in func_defs:
                    if func_name in func_calls:
                        func_calls[func_name] += 1
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path) as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return func_calls

# %% ../nbs/indicators.ipynb 16
def _get_func_defs(code, ignore_private_prefix=True, out_dir=None):
    func_names = []
    try:
        for stmt in ast.walk(ast.parse(code)):
            if isinstance(stmt, ast.FunctionDef):
                inner_cond = (
                    False
                    if ignore_private_prefix and stmt.name.startswith("_")
                    else True
                )
                if inner_cond:
                    func_names.append(stmt.name)
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path) as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return func_names

# %% ../nbs/indicators.ipynb 21
def calls_per_func(nb, out_dir=None):
    nb_cell_code = get_cell_code(nb)
    func_defs = _get_func_defs(nb_cell_code, out_dir)
    func_calls = _count_func_calls(nb_cell_code, func_defs, out_dir)
    return func_calls

# %% ../nbs/indicators.ipynb 23
def calls_per_func_mean(nb, out_dir=None):
    return pd.Series(calls_per_func(nb, out_dir)).mean()

# %% ../nbs/indicators.ipynb 25
def calls_per_func_median(nb, out_dir=None):
    with warnings.catch_warnings():
        warnings.filterwarnings(action="ignore", message="Mean of empty slice")
        return pd.Series(calls_per_func(nb)).median()

# %% ../nbs/indicators.ipynb 34
def _count_inline_asserts(code, func_defs, out_dir=None):
    inline_func_asserts = Counter({k: 0 for k in func_defs})

    try:
        for stmt in ast.walk(ast.parse(code)):
            if isinstance(stmt, ast.Assert):
                for assert_st in ast.walk(stmt):
                    if isinstance(assert_st, ast.Call):
                        func_name = (
                            assert_st.func.id
                            if "id" in assert_st.func.__dict__
                            else assert_st.func.attr
                        )
                        if func_name in inline_func_asserts:
                            inline_func_asserts[func_name] += 1
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path) as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return inline_func_asserts

# %% ../nbs/indicators.ipynb 36
def _count_func_ret_asserts(nb_cell_code, out_dir=None):
    ret_vals = {}
    func_defs = _get_func_defs(nb_cell_code)
    func_ret_asserts = Counter({k: 0 for k in func_defs})
    assert_func_counts = {}
    try:
        for stmt in ast.walk(ast.parse(nb_cell_code)):
            if isinstance(stmt, ast.Assign) and isinstance(stmt.value, ast.Call):
                _update_ret_vals(stmt, ret_vals)

            if isinstance(stmt, ast.Assert):
                assert_func_counts[id(stmt)] = []
                traverse_asserts(
                    stmt, ret_vals, func_ret_asserts, assert_func_counts, stmt.test
                )
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path) as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return func_ret_asserts

# %% ../nbs/indicators.ipynb 37
def _incr_assert_count(
    assert_id, ret_vals, func_ret_asserts, assert_func_counts, return_var
):
    if (
        return_var in ret_vals
        and ret_vals[return_var] not in assert_func_counts[assert_id]
    ):
        assert_func_counts[assert_id].append(ret_vals[return_var])
        if return_var in ret_vals:
            func_ret_asserts[ret_vals[return_var]] += 1

# %% ../nbs/indicators.ipynb 39
def _update_ret_vals(stmt, ret_vals):
    if isinstance(stmt.value.func, ast.Subscript):
        func_name = stmt.func.value.id
    elif isinstance(stmt.value.func, ast.Attribute):
        func_name = stmt.value.func.attr
    else:
        if hasattr(stmt.value.func, "id"):
            func_name = stmt.value.func.id
        elif hasattr(stmt.value.func, "id"):
            func_name = stmt.value.func.id
        elif hasattr(stmt, "func") and hasattr(stmt.func, "attr"):
            func_name = stmt.func.attr
        elif hasattr(stmt.value.func, "func"):
            func_name = (
                stmt.value.func.func.id
                if hasattr(stmt.value.func.func, "id")
                else stmt.value.func.func.attr
            )
    if isinstance(stmt.targets[0], ast.Name):
        ret_vals[stmt.targets[0].id] = func_name
    elif isinstance(stmt.targets[0], ast.Tuple):
        for elts in stmt.targets[0].elts:
            ret_vals[elts.id] = func_name

# %% ../nbs/indicators.ipynb 41
def traverse_asserts(
    stmt: ast.AST, ret_vals, func_ret_asserts, assert_func_counts, node: ast.AST
):
    # increment function assert count if return val can be matched to defined function
    if hasattr(node, "id"):
        _incr_assert_count(
            id(stmt),
            ret_vals,
            func_ret_asserts,
            assert_func_counts,
            node.id,
        )
    # Perform recursive traversals
    children_attrs = ("left", "func", "value", "comparators", "args", "values")
    for attr in children_attrs:
        child = getattr(node, attr, None)
        if isinstance(child, list):
            for item in child:
                traverse_asserts(
                    stmt, ret_vals, func_ret_asserts, assert_func_counts, item
                )
        elif child is not None:
            traverse_asserts(
                stmt, ret_vals, func_ret_asserts, assert_func_counts, child
            )

# %% ../nbs/indicators.ipynb 44
def tests_per_function(nb, out_dir=None):
    nb_cell_code = "\n".join(
        [
            remove_ipython_special_directives(c["source"])
            for c in nb.cells
            if c["cell_type"] == "code"
        ]
    )
    return _tests_per_function_code(nb_cell_code, out_dir)

# %% ../nbs/indicators.ipynb 46
def _tests_per_function_code(nb_cell_code, out_dir=None):
    func_ret_asserts = _count_func_ret_asserts(nb_cell_code, out_dir)
    inline_asserts = _count_inline_asserts(
        nb_cell_code, _get_func_defs(nb_cell_code, out_dir)
    )

    func_ret_asserts.update(inline_asserts)
    return pd.Series(func_ret_asserts)

# %% ../nbs/indicators.ipynb 50
def tests_per_func_mean(nb, out_dir=None):
    return tests_per_function(nb, out_dir).mean()

# %% ../nbs/indicators.ipynb 52
def tests_func_coverage_pct(nb, out_dir=None):
    return tests_per_function(nb, out_dir).clip(upper=1).mean() * 100

# %% ../nbs/indicators.ipynb 57
def calc_ifp(nb_cell_code, out_dir=None):
    stmts_in_func = 0
    stmts_outside_func = 0
    try:
        for stmt in ast.walk(
            ast.parse(remove_ipython_special_directives(nb_cell_code))
        ):
            if isinstance(stmt, ast.FunctionDef) and not stmt.name.startswith("_"):
                for body_item in stmt.body:
                    stmts_in_func += 1
            elif isinstance(stmt, ast.Module):
                for body_item in stmt.body:
                    if not isinstance(body_item, ast.FunctionDef):
                        stmts_outside_func += 1
    except AttributeError as ae:
        if out_dir is not None:
            debug_path = Path(out_dir, gen_parse_filename(code))
            with open(debug_path) as debug_file:
                debug_file.write(code)
            logging.getLogger().info(
                f"Parse failure code dump written to: {debug_path}"
            )
        raise CodeParseError(
            f"Logic error parsing code statement: {stmt} with properties: {stmt.__dict__}",
            ae,
        )
    return (
        0
        if stmts_outside_func + stmts_in_func == 0
        else (stmts_in_func / (stmts_outside_func + stmts_in_func)) * 100
    )

# %% ../nbs/indicators.ipynb 60
def in_func_pct(nb, out_dir=None):
    nb_cell_code = "\n".join(
        [
            remove_ipython_special_directives(c["source"])
            for c in nb.cells
            if c["cell_type"] == "code"
        ]
    )
    if nb_cell_code == "":
        return np.nan
    return calc_ifp(nb_cell_code, out_dir)

# %% ../nbs/indicators.ipynb 64
def markdown_code_pct(nb, out_dir=None):
    md_cells = [c for c in nb.cells if c["cell_type"] == "markdown"]
    code_cells = [c for c in nb.cells if c["cell_type"] == "code"]
    num_code_cells = len(code_cells)
    if num_code_cells == 0:
        return np.nan
    num_md_cells = len(md_cells)
    return (
        100
        if num_code_cells == 0
        else (num_md_cells / (num_md_cells + num_code_cells)) * 100
    )

# %% ../nbs/indicators.ipynb 68
def total_code_len(nb, out_dir=None):
    return sum([len(c["source"]) for c in nb.cells if c["cell_type"] == "code"])

# %% ../nbs/indicators.ipynb 72
def loc_per_md_section(nb, out_dir=None):
    num_md_sections = len(
        [
            c["source"]
            for c in nb.cells
            if c["cell_type"] == "markdown" and c["source"].strip().startswith("#")
        ]
    )
    tcl = total_code_len(nb)
    if tcl == 0 or num_md_sections == 0:
        result = np.nan
    else:
        result = total_code_len(nb) / num_md_sections
    return result

# %% ../nbs/indicators.ipynb 75
indicator_funcs = {
    "calls_per_func_mean": calls_per_func_mean,
    "calls_per_func_median": calls_per_func_median,
    "tests_per_func_mean": tests_per_func_mean,
    "tests_func_coverage_pct": tests_func_coverage_pct,
    "in_func_pct": in_func_pct,
    "markdown_code_pct": markdown_code_pct,
    "loc_per_md_section": loc_per_md_section,
    "total_code_len": total_code_len,
}
